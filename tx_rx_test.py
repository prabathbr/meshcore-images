import asyncio
import os
from meshcore import MeshCore, EventType
import base64

from codec import (
    image_file_to_transmit_string,
    string_to_image_file,
)

SERIAL_PORT = "COM4"   # change this to your serial port
CHANNEL_IDX = 4        # change this to your channel index

IMAGE_WIDTH = 32
IMAGE_HEIGHT = 18
GAP_SIZE = 4           # used by string_to_image_file for preview


async def main():
    # Connect to MeshCore companion over serial
    meshcore = await MeshCore.create_serial(SERIAL_PORT, debug=True)
    print(f"Connected on {SERIAL_PORT}")

    # Start automatic message fetching from the device
    await meshcore.start_auto_message_fetching()

    # Ask user what file to send
    input_filename = input("Enter image filename to send: ").strip()
    if not os.path.isfile(input_filename):
        print(f"File not found: {input_filename}")
        await meshcore.stop_auto_message_fetching()
        await meshcore.disconnect()
        return

    # Build output filename for received image
    base_name, _ = os.path.splitext(os.path.basename(input_filename))
    output_image_rx = f"{base_name}_received.png"

    print(f"Encoding '{input_filename}' for transmission")


    # Encode image into our internal transmission string (1 char per byte)
    tx_str = image_file_to_transmit_string(
        input_filename,
        width=IMAGE_WIDTH,
        height=IMAGE_HEIGHT,
        threshold=128,
    )

    print(f"Raw transmission string length: {len(tx_str)} characters")

    # Convert to bytes for Base64
    tx_bytes = tx_str.encode("latin1")          # perfectly preserves 0â€“255

    # Base64 encode for safe transmission over MeshCore text channel
    tx_b64 = base64.b64encode(tx_bytes).decode("ascii")

    print(f"Base64 encoded length: {len(tx_b64)} characters")


    # Flag so we only decode the first response
    decoded_once = {"done": False}

    async def handle_channel_message(event):
        msg = event.payload

        chan = msg.get("channel_idx")
        text = msg.get("text", "")
        path_len = msg.get("path_len")

        print(f"Received on channel {chan}: len(text)={len(text)} | path_len={path_len}")

        # text contains "sendername: base64_data"
        raw_text = text

        # Extract sender + base64 message
        if ":" in raw_text:
            sender, msg = raw_text.split(":", 1)
            sender = sender.strip()
            msg = msg.strip()
        else:
            sender = "unknown"
            msg = raw_text.strip()

        rx_txt = msg  # clean Base64 payload
        print(f"Received from {sender}, payload length={len(rx_txt)}")


        # Only handle our chosen channel
        if chan != CHANNEL_IDX:
            return

        # Only decode the first matching message
        if decoded_once["done"]:
            print("Already decoded one response, ignoring further messages")
            return

        print(f"Decoding received string into '{output_image_rx}'")

        try:


            # text is the Base64 string received
            rx_bytes = base64.b64decode(rx_txt)
            rx_string = rx_bytes.decode("latin1")    # back to 1-char-per-byte form

            string_to_image_file(
                rx_string,
                output_image_rx,
                width=IMAGE_WIDTH,
                height=IMAGE_HEIGHT,
                gap=GAP_SIZE,
            )



            decoded_once["done"] = True
            print(f"Decoded image saved as '{output_image_rx}'")
            print("Interleaved preview PNG generated by codec as well")
        except Exception as e:
            print(f"Error decoding received image string: {e}")

    # Subscribe first, before sending anything
    subscription = meshcore.subscribe(
        EventType.CHANNEL_MSG_RECV,
        handle_channel_message,
        attribute_filters={"channel_idx": CHANNEL_IDX},
    )

    try:
        # Now safe to transmit
        print(f"Sending encoded image on channel {CHANNEL_IDX}")
        result = await meshcore.commands.send_chan_msg(CHANNEL_IDX, tx_b64)

        if result.type == EventType.ERROR:
            print(f"Error sending encoded image: {result.payload}")
        else:
            print("Encoded image string sent")
            print("Waiting for received string to decode... (Ctrl+C to stop)")

        # Keep program alive so receive handler can run
        while True:
            await asyncio.sleep(3600)

    except KeyboardInterrupt:
        print("Stopping listener...")

    finally:
        meshcore.unsubscribe(subscription)
        await meshcore.stop_auto_message_fetching()
        await meshcore.disconnect()
        print("Disconnected")


if __name__ == "__main__":
    asyncio.run(main())
